import {isNullOrUndefined} from "util";
import AGStopwatch = require("agstopwatch/AGStopwatch");

/**
 Multiples of 3 and 5
 Problem 1
 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

 Find the sum of all the multiples of 3 or 5 below 1000.

 Output to 1000:
 Problem 1 brute force: 233168 Time: 0ms
 Problem 1 composite generator: 233168 Time: 5ms
 Problem 1 modulo generator: 233168 Time: 1ms
 Problem 1 mathiness: 233168 Time: 0ms

 Output to 10000000:
 Problem 1 brute force: 23333331666668 Time: 1568ms
 Problem 1 composite generator: 23333331666668 Time: 5009ms
 Problem 1 modulo generator: 23333331666668 Time: 4348ms
 Problem 1 mathiness: 23333331666668 Time: 0ms
 **/
export class Problem1 {

    private static maxValue :number = 1000;

    /**
     * Solve Problem 1 via summing all multiples of 3 with all multiples of 5 and subtracting
     * all multiples of 15 to remove double-counting.
     */
    static bruteForce(): void {
        let stopWatch:AGStopwatch = new AGStopwatch();
        stopWatch.start();

        let total:number = 0;

        for (let value of multipleGenerator(3, this.maxValue)) {
            total += value;
        }

        for (let value of multipleGenerator(5, this.maxValue)) {
            total += value;
        }

        //Remove double-counted multiples of 3 * 5
        for (let value of multipleGenerator(15, this.maxValue)) {
            total -= value;
        }

        stopWatch.stop();
        console.log(`Problem 1 brute force: ${total} Time: ${stopWatch.elapsed}ms`);
    }

    /**
     * Solve the problem using a generator composed of two multiple generators with duplicate
     * checking.
     */
    static orderedCompositeGenerator(): void {
        let stopWatch:AGStopwatch = new AGStopwatch();
        stopWatch.start();

        let total:number = 0;
        let mult3 = multipleGenerator(3, this.maxValue);
        let mult5 = multipleGenerator(5, this.maxValue);
        for (let value of orderedGenerator(mult3, mult5)) {
            total += value;
        }

        stopWatch.stop();
        console.log(`Problem 1 composite generator: ${total} Time: ${stopWatch.elapsed}ms`);
    }

    /**
     * Solve the problem checking every number from 1 to maxValue for n % 3 || n % 5
     */
    static moddingGenerator() :void {
        let stopWatch:AGStopwatch = new AGStopwatch();
        stopWatch.start();

        let total:number = 0;
        for (let value of moduloZeroGenerator(this.maxValue, 3, 5)) {
            total += value;
        }

        stopWatch.stop();
        console.log(`Problem 1 modulo generator: ${total} Time: ${stopWatch.elapsed}ms`);
    }

    /**
     * Solve the problem by summing the bounded infinite series 1+2+3+...+n
     * 3 + 6 + 9 + ... == 3 * (1 + 2 + 3 + ...)
     */
    static mathiness() :void {
        let stopWatch:AGStopwatch = new AGStopwatch();
        stopWatch.start();

        let lessThanEqualValue = this.maxValue - 1;
        let total:number = 0;
        total += 3 * seriesSum(Math.floor(lessThanEqualValue / 3));
        total += 5 * seriesSum(Math.floor(lessThanEqualValue / 5));
        total -= 15 * seriesSum(Math.floor(lessThanEqualValue / 15));

        stopWatch.stop();
        console.log(`Problem 1 mathiness: ${total} Time: ${stopWatch.elapsed}ms`);
    }
}

/**
 * Generate multiples of a number optionally less than a max value.
 *
 * @param value A value
 * @param max   [optional] A maximum value
 */
function* multipleGenerator(value: number, max: number) {
    let multiple = value;
    while (isNullOrUndefined(max) || multiple < max) {
        yield multiple;
        multiple += value;
    }
}

/**
 * Generate an ordered sequence of numbers generated by a collection of generators.
 *
 * @param generators A collection of number generators
 */
function* orderedGenerator(...generators: IterableIterator<number>[]) {
    let iters: ValuedIterator[] = [];
    let lastValue: number;

    for (let generator of generators) {
        iters.push(new ValuedIterator(generator, generator.next().value));
    }
    iters.sort((a, b) => a.current() - b.current());

    while (iters.length > 0) {
        let iter = iters[0];
        let currentValue = iter.current();
        if (currentValue !== lastValue) {
            yield currentValue;
        }
        lastValue = currentValue;

        if (isNullOrUndefined(iter.next())) {
            iters.splice(0, 1);
        } else {
            iters.sort((a, b) => a.current() - b.current());
        }
    }
}

/**
 * Generate all numbers that are multiples of a collection of factors.
 *
 * @param max       [Nullable] The max value of the generator
 * @param factors   Factors whose multiples to generate
 */
function* moduloZeroGenerator(max: number, ...factors: number[]) {
    let value :number = 1;
    while (isNullOrUndefined(max) || value < max) {
        for (let factor of factors) {
            if (value % factor === 0) {
                yield value;
                break;
            }
        }
        value++;
    }
}

/**
 * Sum the bounded series 1 + 2 + 3 + ... n
 *
 * @param n The maximum bound of the series
 * @returns {number} The series sum
 */
function seriesSum(n :number) {
    return n * (n + 1) / 2;
}

/**
 * Wrapper class that holds a generator and the last-generated value.
 */
class ValuedIterator {
    private iter:IterableIterator<number>;
    private currentValue: number;

    constructor(iter :IterableIterator<number>, lastValue :number) {
        this.iter = iter;
        this.currentValue = lastValue;
    }

    next(): number {
        this.currentValue = this.iter.next().value;
        return this.currentValue;
    }

    current(): number {
        return this.currentValue;
    }
}

export default Problem1;